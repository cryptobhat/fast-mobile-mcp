// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.5
// source: mobile.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "mobile.v1";

export enum Platform {
  PLATFORM_UNSPECIFIED = 0,
  PLATFORM_ANDROID = 1,
  PLATFORM_IOS = 2,
  UNRECOGNIZED = -1,
}

export function platformFromJSON(object: any): Platform {
  switch (object) {
    case 0:
    case "PLATFORM_UNSPECIFIED":
      return Platform.PLATFORM_UNSPECIFIED;
    case 1:
    case "PLATFORM_ANDROID":
      return Platform.PLATFORM_ANDROID;
    case 2:
    case "PLATFORM_IOS":
      return Platform.PLATFORM_IOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Platform.UNRECOGNIZED;
  }
}

export function platformToJSON(object: Platform): string {
  switch (object) {
    case Platform.PLATFORM_UNSPECIFIED:
      return "PLATFORM_UNSPECIFIED";
    case Platform.PLATFORM_ANDROID:
      return "PLATFORM_ANDROID";
    case Platform.PLATFORM_IOS:
      return "PLATFORM_IOS";
    case Platform.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DeviceStatus {
  DEVICE_STATUS_UNSPECIFIED = 0,
  DEVICE_STATUS_READY = 1,
  DEVICE_STATUS_BUSY = 2,
  DEVICE_STATUS_OFFLINE = 3,
  DEVICE_STATUS_UNHEALTHY = 4,
  UNRECOGNIZED = -1,
}

export function deviceStatusFromJSON(object: any): DeviceStatus {
  switch (object) {
    case 0:
    case "DEVICE_STATUS_UNSPECIFIED":
      return DeviceStatus.DEVICE_STATUS_UNSPECIFIED;
    case 1:
    case "DEVICE_STATUS_READY":
      return DeviceStatus.DEVICE_STATUS_READY;
    case 2:
    case "DEVICE_STATUS_BUSY":
      return DeviceStatus.DEVICE_STATUS_BUSY;
    case 3:
    case "DEVICE_STATUS_OFFLINE":
      return DeviceStatus.DEVICE_STATUS_OFFLINE;
    case 4:
    case "DEVICE_STATUS_UNHEALTHY":
      return DeviceStatus.DEVICE_STATUS_UNHEALTHY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceStatus.UNRECOGNIZED;
  }
}

export function deviceStatusToJSON(object: DeviceStatus): string {
  switch (object) {
    case DeviceStatus.DEVICE_STATUS_UNSPECIFIED:
      return "DEVICE_STATUS_UNSPECIFIED";
    case DeviceStatus.DEVICE_STATUS_READY:
      return "DEVICE_STATUS_READY";
    case DeviceStatus.DEVICE_STATUS_BUSY:
      return "DEVICE_STATUS_BUSY";
    case DeviceStatus.DEVICE_STATUS_OFFLINE:
      return "DEVICE_STATUS_OFFLINE";
    case DeviceStatus.DEVICE_STATUS_UNHEALTHY:
      return "DEVICE_STATUS_UNHEALTHY";
    case DeviceStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ActionStatus {
  ACTION_STATUS_UNSPECIFIED = 0,
  ACTION_STATUS_OK = 1,
  ACTION_STATUS_FAILED = 2,
  ACTION_STATUS_TIMEOUT = 3,
  ACTION_STATUS_CANCELLED = 4,
  ACTION_STATUS_INVALID_TARGET = 5,
  UNRECOGNIZED = -1,
}

export function actionStatusFromJSON(object: any): ActionStatus {
  switch (object) {
    case 0:
    case "ACTION_STATUS_UNSPECIFIED":
      return ActionStatus.ACTION_STATUS_UNSPECIFIED;
    case 1:
    case "ACTION_STATUS_OK":
      return ActionStatus.ACTION_STATUS_OK;
    case 2:
    case "ACTION_STATUS_FAILED":
      return ActionStatus.ACTION_STATUS_FAILED;
    case 3:
    case "ACTION_STATUS_TIMEOUT":
      return ActionStatus.ACTION_STATUS_TIMEOUT;
    case 4:
    case "ACTION_STATUS_CANCELLED":
      return ActionStatus.ACTION_STATUS_CANCELLED;
    case 5:
    case "ACTION_STATUS_INVALID_TARGET":
      return ActionStatus.ACTION_STATUS_INVALID_TARGET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActionStatus.UNRECOGNIZED;
  }
}

export function actionStatusToJSON(object: ActionStatus): string {
  switch (object) {
    case ActionStatus.ACTION_STATUS_UNSPECIFIED:
      return "ACTION_STATUS_UNSPECIFIED";
    case ActionStatus.ACTION_STATUS_OK:
      return "ACTION_STATUS_OK";
    case ActionStatus.ACTION_STATUS_FAILED:
      return "ACTION_STATUS_FAILED";
    case ActionStatus.ACTION_STATUS_TIMEOUT:
      return "ACTION_STATUS_TIMEOUT";
    case ActionStatus.ACTION_STATUS_CANCELLED:
      return "ACTION_STATUS_CANCELLED";
    case ActionStatus.ACTION_STATUS_INVALID_TARGET:
      return "ACTION_STATUS_INVALID_TARGET";
    case ActionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Direction {
  DIRECTION_UNSPECIFIED = 0,
  DIRECTION_UP = 1,
  DIRECTION_DOWN = 2,
  DIRECTION_LEFT = 3,
  DIRECTION_RIGHT = 4,
  UNRECOGNIZED = -1,
}

export function directionFromJSON(object: any): Direction {
  switch (object) {
    case 0:
    case "DIRECTION_UNSPECIFIED":
      return Direction.DIRECTION_UNSPECIFIED;
    case 1:
    case "DIRECTION_UP":
      return Direction.DIRECTION_UP;
    case 2:
    case "DIRECTION_DOWN":
      return Direction.DIRECTION_DOWN;
    case 3:
    case "DIRECTION_LEFT":
      return Direction.DIRECTION_LEFT;
    case 4:
    case "DIRECTION_RIGHT":
      return Direction.DIRECTION_RIGHT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Direction.UNRECOGNIZED;
  }
}

export function directionToJSON(object: Direction): string {
  switch (object) {
    case Direction.DIRECTION_UNSPECIFIED:
      return "DIRECTION_UNSPECIFIED";
    case Direction.DIRECTION_UP:
      return "DIRECTION_UP";
    case Direction.DIRECTION_DOWN:
      return "DIRECTION_DOWN";
    case Direction.DIRECTION_LEFT:
      return "DIRECTION_LEFT";
    case Direction.DIRECTION_RIGHT:
      return "DIRECTION_RIGHT";
    case Direction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SelectorField {
  SELECTOR_FIELD_UNSPECIFIED = 0,
  SELECTOR_FIELD_REF_ID = 1,
  SELECTOR_FIELD_TEXT = 2,
  SELECTOR_FIELD_CONTENT_DESC = 3,
  SELECTOR_FIELD_RESOURCE_ID = 4,
  SELECTOR_FIELD_CLASS_NAME = 5,
  SELECTOR_FIELD_PACKAGE_NAME = 6,
  SELECTOR_FIELD_ENABLED = 7,
  SELECTOR_FIELD_CLICKABLE = 8,
  SELECTOR_FIELD_VISIBLE = 9,
  UNRECOGNIZED = -1,
}

export function selectorFieldFromJSON(object: any): SelectorField {
  switch (object) {
    case 0:
    case "SELECTOR_FIELD_UNSPECIFIED":
      return SelectorField.SELECTOR_FIELD_UNSPECIFIED;
    case 1:
    case "SELECTOR_FIELD_REF_ID":
      return SelectorField.SELECTOR_FIELD_REF_ID;
    case 2:
    case "SELECTOR_FIELD_TEXT":
      return SelectorField.SELECTOR_FIELD_TEXT;
    case 3:
    case "SELECTOR_FIELD_CONTENT_DESC":
      return SelectorField.SELECTOR_FIELD_CONTENT_DESC;
    case 4:
    case "SELECTOR_FIELD_RESOURCE_ID":
      return SelectorField.SELECTOR_FIELD_RESOURCE_ID;
    case 5:
    case "SELECTOR_FIELD_CLASS_NAME":
      return SelectorField.SELECTOR_FIELD_CLASS_NAME;
    case 6:
    case "SELECTOR_FIELD_PACKAGE_NAME":
      return SelectorField.SELECTOR_FIELD_PACKAGE_NAME;
    case 7:
    case "SELECTOR_FIELD_ENABLED":
      return SelectorField.SELECTOR_FIELD_ENABLED;
    case 8:
    case "SELECTOR_FIELD_CLICKABLE":
      return SelectorField.SELECTOR_FIELD_CLICKABLE;
    case 9:
    case "SELECTOR_FIELD_VISIBLE":
      return SelectorField.SELECTOR_FIELD_VISIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SelectorField.UNRECOGNIZED;
  }
}

export function selectorFieldToJSON(object: SelectorField): string {
  switch (object) {
    case SelectorField.SELECTOR_FIELD_UNSPECIFIED:
      return "SELECTOR_FIELD_UNSPECIFIED";
    case SelectorField.SELECTOR_FIELD_REF_ID:
      return "SELECTOR_FIELD_REF_ID";
    case SelectorField.SELECTOR_FIELD_TEXT:
      return "SELECTOR_FIELD_TEXT";
    case SelectorField.SELECTOR_FIELD_CONTENT_DESC:
      return "SELECTOR_FIELD_CONTENT_DESC";
    case SelectorField.SELECTOR_FIELD_RESOURCE_ID:
      return "SELECTOR_FIELD_RESOURCE_ID";
    case SelectorField.SELECTOR_FIELD_CLASS_NAME:
      return "SELECTOR_FIELD_CLASS_NAME";
    case SelectorField.SELECTOR_FIELD_PACKAGE_NAME:
      return "SELECTOR_FIELD_PACKAGE_NAME";
    case SelectorField.SELECTOR_FIELD_ENABLED:
      return "SELECTOR_FIELD_ENABLED";
    case SelectorField.SELECTOR_FIELD_CLICKABLE:
      return "SELECTOR_FIELD_CLICKABLE";
    case SelectorField.SELECTOR_FIELD_VISIBLE:
      return "SELECTOR_FIELD_VISIBLE";
    case SelectorField.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SelectorOperator {
  SELECTOR_OPERATOR_UNSPECIFIED = 0,
  SELECTOR_OPERATOR_EQ = 1,
  SELECTOR_OPERATOR_CONTAINS = 2,
  SELECTOR_OPERATOR_PREFIX = 3,
  SELECTOR_OPERATOR_SUFFIX = 4,
  SELECTOR_OPERATOR_REGEX = 5,
  UNRECOGNIZED = -1,
}

export function selectorOperatorFromJSON(object: any): SelectorOperator {
  switch (object) {
    case 0:
    case "SELECTOR_OPERATOR_UNSPECIFIED":
      return SelectorOperator.SELECTOR_OPERATOR_UNSPECIFIED;
    case 1:
    case "SELECTOR_OPERATOR_EQ":
      return SelectorOperator.SELECTOR_OPERATOR_EQ;
    case 2:
    case "SELECTOR_OPERATOR_CONTAINS":
      return SelectorOperator.SELECTOR_OPERATOR_CONTAINS;
    case 3:
    case "SELECTOR_OPERATOR_PREFIX":
      return SelectorOperator.SELECTOR_OPERATOR_PREFIX;
    case 4:
    case "SELECTOR_OPERATOR_SUFFIX":
      return SelectorOperator.SELECTOR_OPERATOR_SUFFIX;
    case 5:
    case "SELECTOR_OPERATOR_REGEX":
      return SelectorOperator.SELECTOR_OPERATOR_REGEX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SelectorOperator.UNRECOGNIZED;
  }
}

export function selectorOperatorToJSON(object: SelectorOperator): string {
  switch (object) {
    case SelectorOperator.SELECTOR_OPERATOR_UNSPECIFIED:
      return "SELECTOR_OPERATOR_UNSPECIFIED";
    case SelectorOperator.SELECTOR_OPERATOR_EQ:
      return "SELECTOR_OPERATOR_EQ";
    case SelectorOperator.SELECTOR_OPERATOR_CONTAINS:
      return "SELECTOR_OPERATOR_CONTAINS";
    case SelectorOperator.SELECTOR_OPERATOR_PREFIX:
      return "SELECTOR_OPERATOR_PREFIX";
    case SelectorOperator.SELECTOR_OPERATOR_SUFFIX:
      return "SELECTOR_OPERATOR_SUFFIX";
    case SelectorOperator.SELECTOR_OPERATOR_REGEX:
      return "SELECTOR_OPERATOR_REGEX";
    case SelectorOperator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RequestOptions {
  requestId: string;
  timeoutMs: number;
}

export interface Coordinates {
  x: number;
  y: number;
}

export interface Bounds {
  left: number;
  top: number;
  right: number;
  bottom: number;
}

export interface Device {
  deviceId: string;
  platform: Platform;
  name: string;
  model: string;
  osVersion: string;
  isSimulator: boolean;
  status: DeviceStatus;
  lastSeenUnixMs: string;
  capabilities: { [key: string]: string };
}

export interface Device_CapabilitiesEntry {
  key: string;
  value: string;
}

export interface UiNode {
  refId: string;
  parentRefId: string;
  index: number;
  text: string;
  contentDesc: string;
  resourceId: string;
  className: string;
  packageName: string;
  bounds: Bounds | undefined;
  enabled: boolean;
  clickable: boolean;
  focusable: boolean;
  visible: boolean;
  selected: boolean;
  checked: boolean;
}

export interface Element {
  refId: string;
  node: UiNode | undefined;
}

export interface SelectorClause {
  field: SelectorField;
  operator: SelectorOperator;
  value: string;
}

export interface Selector {
  clauses: SelectorClause[];
  matchAll: boolean;
  withinRefId: string;
  limit: number;
}

export interface ListDevicesRequest {
  platformFilter: Platform;
  readyOnly: boolean;
  options: RequestOptions | undefined;
}

export interface ListDevicesResponse {
  devices: Device[];
  cacheAgeMs: string;
}

export interface GetActiveAppRequest {
  deviceId: string;
  options: RequestOptions | undefined;
}

export interface GetActiveAppResponse {
  deviceId: string;
  bundleId: string;
  appName: string;
  isForeground: boolean;
  observedAtUnixMs: string;
}

export interface GetUITreeRequest {
  deviceId: string;
  forceRefresh: boolean;
  nodeLimit: number;
  depthLimit: number;
  cursor: string;
  options: RequestOptions | undefined;
}

export interface GetUITreeResponse {
  deviceId: string;
  snapshotId: string;
  expiresAtUnixMs: string;
  nodes: UiNode[];
  totalNodes: number;
  nextCursor: string;
}

export interface FindElementsRequest {
  deviceId: string;
  selector: Selector | undefined;
  snapshotId: string;
  limit: number;
  cursor: string;
  includeNodes: boolean;
  options: RequestOptions | undefined;
}

export interface FindElementsResponse {
  deviceId: string;
  snapshotId: string;
  elements: Element[];
  nextCursor: string;
  totalMatched: number;
}

export interface TapRequest {
  deviceId: string;
  refId?: string | undefined;
  coordinates?: Coordinates | undefined;
  selector?: Selector | undefined;
  snapshotId: string;
  tapCount: number;
  options: RequestOptions | undefined;
}

export interface TypeRequest {
  deviceId: string;
  refId?: string | undefined;
  coordinates?: Coordinates | undefined;
  selector?: Selector | undefined;
  snapshotId: string;
  text: string;
  clearBeforeType: boolean;
  options: RequestOptions | undefined;
}

export interface SwipeRequest {
  deviceId: string;
  start: Coordinates | undefined;
  end: Coordinates | undefined;
  direction: Direction;
  distancePx: number;
  durationMs: number;
  options: RequestOptions | undefined;
}

export interface ActionResponse {
  deviceId: string;
  actionId: string;
  status: ActionStatus;
  startedAtUnixMs: string;
  completedAtUnixMs: string;
  errorCode: string;
  errorMessage: string;
  metadata: { [key: string]: string };
}

export interface ActionResponse_MetadataEntry {
  key: string;
  value: string;
}

export interface ScreenshotStreamRequest {
  deviceId: string;
  maxFps: number;
  jpegQuality: number;
  maxWidth: number;
  maxHeight: number;
  maxFrames: number;
  options: RequestOptions | undefined;
}

export interface ScreenshotFrameMeta {
  frameId: string;
  deviceId: string;
  width: number;
  height: number;
  mimeType: string;
  totalBytes: string;
  chunkCount: number;
  capturedAtUnixMs: string;
}

export interface ScreenshotChunk {
  frameId: string;
  chunkIndex: number;
  data: Uint8Array;
}

export interface StreamHeartbeat {
  unixMs: string;
}

export interface StreamEnd {
  reason: string;
}

export interface ScreenshotStreamEvent {
  frameMeta?: ScreenshotFrameMeta | undefined;
  chunk?: ScreenshotChunk | undefined;
  heartbeat?: StreamHeartbeat | undefined;
  end?: StreamEnd | undefined;
}

function createBaseRequestOptions(): RequestOptions {
  return { requestId: "", timeoutMs: 0 };
}

export const RequestOptions = {
  encode(message: RequestOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(16).int32(message.timeoutMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeoutMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestOptions {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
    };
  },

  toJSON(message: RequestOptions): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestOptions>, I>>(base?: I): RequestOptions {
    return RequestOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestOptions>, I>>(object: I): RequestOptions {
    const message = createBaseRequestOptions();
    message.requestId = object.requestId ?? "";
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseCoordinates(): Coordinates {
  return { x: 0, y: 0 };
}

export const Coordinates = {
  encode(message: Coordinates, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Coordinates {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoordinates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Coordinates {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Coordinates): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Coordinates>, I>>(base?: I): Coordinates {
    return Coordinates.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Coordinates>, I>>(object: I): Coordinates {
    const message = createBaseCoordinates();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseBounds(): Bounds {
  return { left: 0, top: 0, right: 0, bottom: 0 };
}

export const Bounds = {
  encode(message: Bounds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.left !== 0) {
      writer.uint32(8).int32(message.left);
    }
    if (message.top !== 0) {
      writer.uint32(16).int32(message.top);
    }
    if (message.right !== 0) {
      writer.uint32(24).int32(message.right);
    }
    if (message.bottom !== 0) {
      writer.uint32(32).int32(message.bottom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bounds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.left = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.top = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.right = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bottom = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bounds {
    return {
      left: isSet(object.left) ? globalThis.Number(object.left) : 0,
      top: isSet(object.top) ? globalThis.Number(object.top) : 0,
      right: isSet(object.right) ? globalThis.Number(object.right) : 0,
      bottom: isSet(object.bottom) ? globalThis.Number(object.bottom) : 0,
    };
  },

  toJSON(message: Bounds): unknown {
    const obj: any = {};
    if (message.left !== 0) {
      obj.left = Math.round(message.left);
    }
    if (message.top !== 0) {
      obj.top = Math.round(message.top);
    }
    if (message.right !== 0) {
      obj.right = Math.round(message.right);
    }
    if (message.bottom !== 0) {
      obj.bottom = Math.round(message.bottom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bounds>, I>>(base?: I): Bounds {
    return Bounds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bounds>, I>>(object: I): Bounds {
    const message = createBaseBounds();
    message.left = object.left ?? 0;
    message.top = object.top ?? 0;
    message.right = object.right ?? 0;
    message.bottom = object.bottom ?? 0;
    return message;
  },
};

function createBaseDevice(): Device {
  return {
    deviceId: "",
    platform: 0,
    name: "",
    model: "",
    osVersion: "",
    isSimulator: false,
    status: 0,
    lastSeenUnixMs: "0",
    capabilities: {},
  };
}

export const Device = {
  encode(message: Device, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.platform !== 0) {
      writer.uint32(16).int32(message.platform);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.model !== "") {
      writer.uint32(34).string(message.model);
    }
    if (message.osVersion !== "") {
      writer.uint32(42).string(message.osVersion);
    }
    if (message.isSimulator !== false) {
      writer.uint32(48).bool(message.isSimulator);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.lastSeenUnixMs !== "0") {
      writer.uint32(64).int64(message.lastSeenUnixMs);
    }
    Object.entries(message.capabilities).forEach(([key, value]) => {
      Device_CapabilitiesEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Device {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.model = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.osVersion = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isSimulator = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.lastSeenUnixMs = longToString(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Device_CapabilitiesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.capabilities[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      osVersion: isSet(object.osVersion) ? globalThis.String(object.osVersion) : "",
      isSimulator: isSet(object.isSimulator) ? globalThis.Boolean(object.isSimulator) : false,
      status: isSet(object.status) ? deviceStatusFromJSON(object.status) : 0,
      lastSeenUnixMs: isSet(object.lastSeenUnixMs) ? globalThis.String(object.lastSeenUnixMs) : "0",
      capabilities: isObject(object.capabilities)
        ? Object.entries(object.capabilities).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Device): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.osVersion !== "") {
      obj.osVersion = message.osVersion;
    }
    if (message.isSimulator !== false) {
      obj.isSimulator = message.isSimulator;
    }
    if (message.status !== 0) {
      obj.status = deviceStatusToJSON(message.status);
    }
    if (message.lastSeenUnixMs !== "0") {
      obj.lastSeenUnixMs = message.lastSeenUnixMs;
    }
    if (message.capabilities) {
      const entries = Object.entries(message.capabilities);
      if (entries.length > 0) {
        obj.capabilities = {};
        entries.forEach(([k, v]) => {
          obj.capabilities[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Device>, I>>(base?: I): Device {
    return Device.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Device>, I>>(object: I): Device {
    const message = createBaseDevice();
    message.deviceId = object.deviceId ?? "";
    message.platform = object.platform ?? 0;
    message.name = object.name ?? "";
    message.model = object.model ?? "";
    message.osVersion = object.osVersion ?? "";
    message.isSimulator = object.isSimulator ?? false;
    message.status = object.status ?? 0;
    message.lastSeenUnixMs = object.lastSeenUnixMs ?? "0";
    message.capabilities = Object.entries(object.capabilities ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDevice_CapabilitiesEntry(): Device_CapabilitiesEntry {
  return { key: "", value: "" };
}

export const Device_CapabilitiesEntry = {
  encode(message: Device_CapabilitiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Device_CapabilitiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice_CapabilitiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device_CapabilitiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Device_CapabilitiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Device_CapabilitiesEntry>, I>>(base?: I): Device_CapabilitiesEntry {
    return Device_CapabilitiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Device_CapabilitiesEntry>, I>>(object: I): Device_CapabilitiesEntry {
    const message = createBaseDevice_CapabilitiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUiNode(): UiNode {
  return {
    refId: "",
    parentRefId: "",
    index: 0,
    text: "",
    contentDesc: "",
    resourceId: "",
    className: "",
    packageName: "",
    bounds: undefined,
    enabled: false,
    clickable: false,
    focusable: false,
    visible: false,
    selected: false,
    checked: false,
  };
}

export const UiNode = {
  encode(message: UiNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refId !== "") {
      writer.uint32(10).string(message.refId);
    }
    if (message.parentRefId !== "") {
      writer.uint32(18).string(message.parentRefId);
    }
    if (message.index !== 0) {
      writer.uint32(24).int32(message.index);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.contentDesc !== "") {
      writer.uint32(42).string(message.contentDesc);
    }
    if (message.resourceId !== "") {
      writer.uint32(50).string(message.resourceId);
    }
    if (message.className !== "") {
      writer.uint32(58).string(message.className);
    }
    if (message.packageName !== "") {
      writer.uint32(66).string(message.packageName);
    }
    if (message.bounds !== undefined) {
      Bounds.encode(message.bounds, writer.uint32(74).fork()).ldelim();
    }
    if (message.enabled !== false) {
      writer.uint32(80).bool(message.enabled);
    }
    if (message.clickable !== false) {
      writer.uint32(88).bool(message.clickable);
    }
    if (message.focusable !== false) {
      writer.uint32(96).bool(message.focusable);
    }
    if (message.visible !== false) {
      writer.uint32(104).bool(message.visible);
    }
    if (message.selected !== false) {
      writer.uint32(112).bool(message.selected);
    }
    if (message.checked !== false) {
      writer.uint32(120).bool(message.checked);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UiNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUiNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentRefId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contentDesc = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.className = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.packageName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.bounds = Bounds.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.clickable = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.focusable = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.visible = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.selected = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.checked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UiNode {
    return {
      refId: isSet(object.refId) ? globalThis.String(object.refId) : "",
      parentRefId: isSet(object.parentRefId) ? globalThis.String(object.parentRefId) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      contentDesc: isSet(object.contentDesc) ? globalThis.String(object.contentDesc) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      className: isSet(object.className) ? globalThis.String(object.className) : "",
      packageName: isSet(object.packageName) ? globalThis.String(object.packageName) : "",
      bounds: isSet(object.bounds) ? Bounds.fromJSON(object.bounds) : undefined,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      clickable: isSet(object.clickable) ? globalThis.Boolean(object.clickable) : false,
      focusable: isSet(object.focusable) ? globalThis.Boolean(object.focusable) : false,
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      selected: isSet(object.selected) ? globalThis.Boolean(object.selected) : false,
      checked: isSet(object.checked) ? globalThis.Boolean(object.checked) : false,
    };
  },

  toJSON(message: UiNode): unknown {
    const obj: any = {};
    if (message.refId !== "") {
      obj.refId = message.refId;
    }
    if (message.parentRefId !== "") {
      obj.parentRefId = message.parentRefId;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.contentDesc !== "") {
      obj.contentDesc = message.contentDesc;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.className !== "") {
      obj.className = message.className;
    }
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.bounds !== undefined) {
      obj.bounds = Bounds.toJSON(message.bounds);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.clickable !== false) {
      obj.clickable = message.clickable;
    }
    if (message.focusable !== false) {
      obj.focusable = message.focusable;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.selected !== false) {
      obj.selected = message.selected;
    }
    if (message.checked !== false) {
      obj.checked = message.checked;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UiNode>, I>>(base?: I): UiNode {
    return UiNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UiNode>, I>>(object: I): UiNode {
    const message = createBaseUiNode();
    message.refId = object.refId ?? "";
    message.parentRefId = object.parentRefId ?? "";
    message.index = object.index ?? 0;
    message.text = object.text ?? "";
    message.contentDesc = object.contentDesc ?? "";
    message.resourceId = object.resourceId ?? "";
    message.className = object.className ?? "";
    message.packageName = object.packageName ?? "";
    message.bounds = (object.bounds !== undefined && object.bounds !== null)
      ? Bounds.fromPartial(object.bounds)
      : undefined;
    message.enabled = object.enabled ?? false;
    message.clickable = object.clickable ?? false;
    message.focusable = object.focusable ?? false;
    message.visible = object.visible ?? false;
    message.selected = object.selected ?? false;
    message.checked = object.checked ?? false;
    return message;
  },
};

function createBaseElement(): Element {
  return { refId: "", node: undefined };
}

export const Element = {
  encode(message: Element, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refId !== "") {
      writer.uint32(10).string(message.refId);
    }
    if (message.node !== undefined) {
      UiNode.encode(message.node, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Element {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.node = UiNode.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Element {
    return {
      refId: isSet(object.refId) ? globalThis.String(object.refId) : "",
      node: isSet(object.node) ? UiNode.fromJSON(object.node) : undefined,
    };
  },

  toJSON(message: Element): unknown {
    const obj: any = {};
    if (message.refId !== "") {
      obj.refId = message.refId;
    }
    if (message.node !== undefined) {
      obj.node = UiNode.toJSON(message.node);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Element>, I>>(base?: I): Element {
    return Element.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Element>, I>>(object: I): Element {
    const message = createBaseElement();
    message.refId = object.refId ?? "";
    message.node = (object.node !== undefined && object.node !== null) ? UiNode.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseSelectorClause(): SelectorClause {
  return { field: 0, operator: 0, value: "" };
}

export const SelectorClause = {
  encode(message: SelectorClause, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== 0) {
      writer.uint32(8).int32(message.field);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SelectorClause {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectorClause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.field = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectorClause {
    return {
      field: isSet(object.field) ? selectorFieldFromJSON(object.field) : 0,
      operator: isSet(object.operator) ? selectorOperatorFromJSON(object.operator) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SelectorClause): unknown {
    const obj: any = {};
    if (message.field !== 0) {
      obj.field = selectorFieldToJSON(message.field);
    }
    if (message.operator !== 0) {
      obj.operator = selectorOperatorToJSON(message.operator);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectorClause>, I>>(base?: I): SelectorClause {
    return SelectorClause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectorClause>, I>>(object: I): SelectorClause {
    const message = createBaseSelectorClause();
    message.field = object.field ?? 0;
    message.operator = object.operator ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSelector(): Selector {
  return { clauses: [], matchAll: false, withinRefId: "", limit: 0 };
}

export const Selector = {
  encode(message: Selector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.clauses) {
      SelectorClause.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.matchAll !== false) {
      writer.uint32(16).bool(message.matchAll);
    }
    if (message.withinRefId !== "") {
      writer.uint32(26).string(message.withinRefId);
    }
    if (message.limit !== 0) {
      writer.uint32(32).uint32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Selector {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clauses.push(SelectorClause.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchAll = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.withinRefId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Selector {
    return {
      clauses: globalThis.Array.isArray(object?.clauses)
        ? object.clauses.map((e: any) => SelectorClause.fromJSON(e))
        : [],
      matchAll: isSet(object.matchAll) ? globalThis.Boolean(object.matchAll) : false,
      withinRefId: isSet(object.withinRefId) ? globalThis.String(object.withinRefId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: Selector): unknown {
    const obj: any = {};
    if (message.clauses?.length) {
      obj.clauses = message.clauses.map((e) => SelectorClause.toJSON(e));
    }
    if (message.matchAll !== false) {
      obj.matchAll = message.matchAll;
    }
    if (message.withinRefId !== "") {
      obj.withinRefId = message.withinRefId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Selector>, I>>(base?: I): Selector {
    return Selector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Selector>, I>>(object: I): Selector {
    const message = createBaseSelector();
    message.clauses = object.clauses?.map((e) => SelectorClause.fromPartial(e)) || [];
    message.matchAll = object.matchAll ?? false;
    message.withinRefId = object.withinRefId ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseListDevicesRequest(): ListDevicesRequest {
  return { platformFilter: 0, readyOnly: false, options: undefined };
}

export const ListDevicesRequest = {
  encode(message: ListDevicesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.platformFilter !== 0) {
      writer.uint32(8).int32(message.platformFilter);
    }
    if (message.readyOnly !== false) {
      writer.uint32(16).bool(message.readyOnly);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDevicesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDevicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.platformFilter = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.readyOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDevicesRequest {
    return {
      platformFilter: isSet(object.platformFilter) ? platformFromJSON(object.platformFilter) : 0,
      readyOnly: isSet(object.readyOnly) ? globalThis.Boolean(object.readyOnly) : false,
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ListDevicesRequest): unknown {
    const obj: any = {};
    if (message.platformFilter !== 0) {
      obj.platformFilter = platformToJSON(message.platformFilter);
    }
    if (message.readyOnly !== false) {
      obj.readyOnly = message.readyOnly;
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDevicesRequest>, I>>(base?: I): ListDevicesRequest {
    return ListDevicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDevicesRequest>, I>>(object: I): ListDevicesRequest {
    const message = createBaseListDevicesRequest();
    message.platformFilter = object.platformFilter ?? 0;
    message.readyOnly = object.readyOnly ?? false;
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseListDevicesResponse(): ListDevicesResponse {
  return { devices: [], cacheAgeMs: "0" };
}

export const ListDevicesResponse = {
  encode(message: ListDevicesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cacheAgeMs !== "0") {
      writer.uint32(16).int64(message.cacheAgeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDevicesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDevicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cacheAgeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDevicesResponse {
    return {
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
      cacheAgeMs: isSet(object.cacheAgeMs) ? globalThis.String(object.cacheAgeMs) : "0",
    };
  },

  toJSON(message: ListDevicesResponse): unknown {
    const obj: any = {};
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    if (message.cacheAgeMs !== "0") {
      obj.cacheAgeMs = message.cacheAgeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDevicesResponse>, I>>(base?: I): ListDevicesResponse {
    return ListDevicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDevicesResponse>, I>>(object: I): ListDevicesResponse {
    const message = createBaseListDevicesResponse();
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    message.cacheAgeMs = object.cacheAgeMs ?? "0";
    return message;
  },
};

function createBaseGetActiveAppRequest(): GetActiveAppRequest {
  return { deviceId: "", options: undefined };
}

export const GetActiveAppRequest = {
  encode(message: GetActiveAppRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetActiveAppRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveAppRequest {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: GetActiveAppRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveAppRequest>, I>>(base?: I): GetActiveAppRequest {
    return GetActiveAppRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveAppRequest>, I>>(object: I): GetActiveAppRequest {
    const message = createBaseGetActiveAppRequest();
    message.deviceId = object.deviceId ?? "";
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseGetActiveAppResponse(): GetActiveAppResponse {
  return { deviceId: "", bundleId: "", appName: "", isForeground: false, observedAtUnixMs: "0" };
}

export const GetActiveAppResponse = {
  encode(message: GetActiveAppResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.bundleId !== "") {
      writer.uint32(18).string(message.bundleId);
    }
    if (message.appName !== "") {
      writer.uint32(26).string(message.appName);
    }
    if (message.isForeground !== false) {
      writer.uint32(32).bool(message.isForeground);
    }
    if (message.observedAtUnixMs !== "0") {
      writer.uint32(40).int64(message.observedAtUnixMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetActiveAppResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveAppResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bundleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.appName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isForeground = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.observedAtUnixMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveAppResponse {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      bundleId: isSet(object.bundleId) ? globalThis.String(object.bundleId) : "",
      appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
      isForeground: isSet(object.isForeground) ? globalThis.Boolean(object.isForeground) : false,
      observedAtUnixMs: isSet(object.observedAtUnixMs) ? globalThis.String(object.observedAtUnixMs) : "0",
    };
  },

  toJSON(message: GetActiveAppResponse): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.bundleId !== "") {
      obj.bundleId = message.bundleId;
    }
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.isForeground !== false) {
      obj.isForeground = message.isForeground;
    }
    if (message.observedAtUnixMs !== "0") {
      obj.observedAtUnixMs = message.observedAtUnixMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveAppResponse>, I>>(base?: I): GetActiveAppResponse {
    return GetActiveAppResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveAppResponse>, I>>(object: I): GetActiveAppResponse {
    const message = createBaseGetActiveAppResponse();
    message.deviceId = object.deviceId ?? "";
    message.bundleId = object.bundleId ?? "";
    message.appName = object.appName ?? "";
    message.isForeground = object.isForeground ?? false;
    message.observedAtUnixMs = object.observedAtUnixMs ?? "0";
    return message;
  },
};

function createBaseGetUITreeRequest(): GetUITreeRequest {
  return { deviceId: "", forceRefresh: false, nodeLimit: 0, depthLimit: 0, cursor: "", options: undefined };
}

export const GetUITreeRequest = {
  encode(message: GetUITreeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.forceRefresh !== false) {
      writer.uint32(16).bool(message.forceRefresh);
    }
    if (message.nodeLimit !== 0) {
      writer.uint32(24).uint32(message.nodeLimit);
    }
    if (message.depthLimit !== 0) {
      writer.uint32(32).uint32(message.depthLimit);
    }
    if (message.cursor !== "") {
      writer.uint32(42).string(message.cursor);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUITreeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUITreeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.forceRefresh = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeLimit = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.depthLimit = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUITreeRequest {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      forceRefresh: isSet(object.forceRefresh) ? globalThis.Boolean(object.forceRefresh) : false,
      nodeLimit: isSet(object.nodeLimit) ? globalThis.Number(object.nodeLimit) : 0,
      depthLimit: isSet(object.depthLimit) ? globalThis.Number(object.depthLimit) : 0,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: GetUITreeRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.forceRefresh !== false) {
      obj.forceRefresh = message.forceRefresh;
    }
    if (message.nodeLimit !== 0) {
      obj.nodeLimit = Math.round(message.nodeLimit);
    }
    if (message.depthLimit !== 0) {
      obj.depthLimit = Math.round(message.depthLimit);
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUITreeRequest>, I>>(base?: I): GetUITreeRequest {
    return GetUITreeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUITreeRequest>, I>>(object: I): GetUITreeRequest {
    const message = createBaseGetUITreeRequest();
    message.deviceId = object.deviceId ?? "";
    message.forceRefresh = object.forceRefresh ?? false;
    message.nodeLimit = object.nodeLimit ?? 0;
    message.depthLimit = object.depthLimit ?? 0;
    message.cursor = object.cursor ?? "";
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseGetUITreeResponse(): GetUITreeResponse {
  return { deviceId: "", snapshotId: "", expiresAtUnixMs: "0", nodes: [], totalNodes: 0, nextCursor: "" };
}

export const GetUITreeResponse = {
  encode(message: GetUITreeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.snapshotId !== "") {
      writer.uint32(18).string(message.snapshotId);
    }
    if (message.expiresAtUnixMs !== "0") {
      writer.uint32(24).int64(message.expiresAtUnixMs);
    }
    for (const v of message.nodes) {
      UiNode.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.totalNodes !== 0) {
      writer.uint32(40).uint32(message.totalNodes);
    }
    if (message.nextCursor !== "") {
      writer.uint32(50).string(message.nextCursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUITreeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUITreeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.expiresAtUnixMs = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodes.push(UiNode.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalNodes = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUITreeResponse {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      expiresAtUnixMs: isSet(object.expiresAtUnixMs) ? globalThis.String(object.expiresAtUnixMs) : "0",
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => UiNode.fromJSON(e)) : [],
      totalNodes: isSet(object.totalNodes) ? globalThis.Number(object.totalNodes) : 0,
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : "",
    };
  },

  toJSON(message: GetUITreeResponse): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.expiresAtUnixMs !== "0") {
      obj.expiresAtUnixMs = message.expiresAtUnixMs;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => UiNode.toJSON(e));
    }
    if (message.totalNodes !== 0) {
      obj.totalNodes = Math.round(message.totalNodes);
    }
    if (message.nextCursor !== "") {
      obj.nextCursor = message.nextCursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUITreeResponse>, I>>(base?: I): GetUITreeResponse {
    return GetUITreeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUITreeResponse>, I>>(object: I): GetUITreeResponse {
    const message = createBaseGetUITreeResponse();
    message.deviceId = object.deviceId ?? "";
    message.snapshotId = object.snapshotId ?? "";
    message.expiresAtUnixMs = object.expiresAtUnixMs ?? "0";
    message.nodes = object.nodes?.map((e) => UiNode.fromPartial(e)) || [];
    message.totalNodes = object.totalNodes ?? 0;
    message.nextCursor = object.nextCursor ?? "";
    return message;
  },
};

function createBaseFindElementsRequest(): FindElementsRequest {
  return {
    deviceId: "",
    selector: undefined,
    snapshotId: "",
    limit: 0,
    cursor: "",
    includeNodes: false,
    options: undefined,
  };
}

export const FindElementsRequest = {
  encode(message: FindElementsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.selector !== undefined) {
      Selector.encode(message.selector, writer.uint32(18).fork()).ldelim();
    }
    if (message.snapshotId !== "") {
      writer.uint32(26).string(message.snapshotId);
    }
    if (message.limit !== 0) {
      writer.uint32(32).uint32(message.limit);
    }
    if (message.cursor !== "") {
      writer.uint32(42).string(message.cursor);
    }
    if (message.includeNodes !== false) {
      writer.uint32(48).bool(message.includeNodes);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FindElementsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindElementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.selector = Selector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.includeNodes = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindElementsRequest {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      selector: isSet(object.selector) ? Selector.fromJSON(object.selector) : undefined,
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      includeNodes: isSet(object.includeNodes) ? globalThis.Boolean(object.includeNodes) : false,
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: FindElementsRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.selector !== undefined) {
      obj.selector = Selector.toJSON(message.selector);
    }
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.includeNodes !== false) {
      obj.includeNodes = message.includeNodes;
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindElementsRequest>, I>>(base?: I): FindElementsRequest {
    return FindElementsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindElementsRequest>, I>>(object: I): FindElementsRequest {
    const message = createBaseFindElementsRequest();
    message.deviceId = object.deviceId ?? "";
    message.selector = (object.selector !== undefined && object.selector !== null)
      ? Selector.fromPartial(object.selector)
      : undefined;
    message.snapshotId = object.snapshotId ?? "";
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? "";
    message.includeNodes = object.includeNodes ?? false;
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseFindElementsResponse(): FindElementsResponse {
  return { deviceId: "", snapshotId: "", elements: [], nextCursor: "", totalMatched: 0 };
}

export const FindElementsResponse = {
  encode(message: FindElementsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.snapshotId !== "") {
      writer.uint32(18).string(message.snapshotId);
    }
    for (const v of message.elements) {
      Element.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.nextCursor !== "") {
      writer.uint32(34).string(message.nextCursor);
    }
    if (message.totalMatched !== 0) {
      writer.uint32(40).uint32(message.totalMatched);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FindElementsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindElementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.elements.push(Element.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalMatched = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindElementsResponse {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      elements: globalThis.Array.isArray(object?.elements) ? object.elements.map((e: any) => Element.fromJSON(e)) : [],
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : "",
      totalMatched: isSet(object.totalMatched) ? globalThis.Number(object.totalMatched) : 0,
    };
  },

  toJSON(message: FindElementsResponse): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => Element.toJSON(e));
    }
    if (message.nextCursor !== "") {
      obj.nextCursor = message.nextCursor;
    }
    if (message.totalMatched !== 0) {
      obj.totalMatched = Math.round(message.totalMatched);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindElementsResponse>, I>>(base?: I): FindElementsResponse {
    return FindElementsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindElementsResponse>, I>>(object: I): FindElementsResponse {
    const message = createBaseFindElementsResponse();
    message.deviceId = object.deviceId ?? "";
    message.snapshotId = object.snapshotId ?? "";
    message.elements = object.elements?.map((e) => Element.fromPartial(e)) || [];
    message.nextCursor = object.nextCursor ?? "";
    message.totalMatched = object.totalMatched ?? 0;
    return message;
  },
};

function createBaseTapRequest(): TapRequest {
  return {
    deviceId: "",
    refId: undefined,
    coordinates: undefined,
    selector: undefined,
    snapshotId: "",
    tapCount: 0,
    options: undefined,
  };
}

export const TapRequest = {
  encode(message: TapRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.refId !== undefined) {
      writer.uint32(18).string(message.refId);
    }
    if (message.coordinates !== undefined) {
      Coordinates.encode(message.coordinates, writer.uint32(26).fork()).ldelim();
    }
    if (message.selector !== undefined) {
      Selector.encode(message.selector, writer.uint32(34).fork()).ldelim();
    }
    if (message.snapshotId !== "") {
      writer.uint32(42).string(message.snapshotId);
    }
    if (message.tapCount !== 0) {
      writer.uint32(48).int32(message.tapCount);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TapRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.coordinates = Coordinates.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.selector = Selector.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tapCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TapRequest {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      refId: isSet(object.refId) ? globalThis.String(object.refId) : undefined,
      coordinates: isSet(object.coordinates) ? Coordinates.fromJSON(object.coordinates) : undefined,
      selector: isSet(object.selector) ? Selector.fromJSON(object.selector) : undefined,
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      tapCount: isSet(object.tapCount) ? globalThis.Number(object.tapCount) : 0,
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: TapRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.refId !== undefined) {
      obj.refId = message.refId;
    }
    if (message.coordinates !== undefined) {
      obj.coordinates = Coordinates.toJSON(message.coordinates);
    }
    if (message.selector !== undefined) {
      obj.selector = Selector.toJSON(message.selector);
    }
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.tapCount !== 0) {
      obj.tapCount = Math.round(message.tapCount);
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TapRequest>, I>>(base?: I): TapRequest {
    return TapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TapRequest>, I>>(object: I): TapRequest {
    const message = createBaseTapRequest();
    message.deviceId = object.deviceId ?? "";
    message.refId = object.refId ?? undefined;
    message.coordinates = (object.coordinates !== undefined && object.coordinates !== null)
      ? Coordinates.fromPartial(object.coordinates)
      : undefined;
    message.selector = (object.selector !== undefined && object.selector !== null)
      ? Selector.fromPartial(object.selector)
      : undefined;
    message.snapshotId = object.snapshotId ?? "";
    message.tapCount = object.tapCount ?? 0;
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseTypeRequest(): TypeRequest {
  return {
    deviceId: "",
    refId: undefined,
    coordinates: undefined,
    selector: undefined,
    snapshotId: "",
    text: "",
    clearBeforeType: false,
    options: undefined,
  };
}

export const TypeRequest = {
  encode(message: TypeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.refId !== undefined) {
      writer.uint32(18).string(message.refId);
    }
    if (message.coordinates !== undefined) {
      Coordinates.encode(message.coordinates, writer.uint32(26).fork()).ldelim();
    }
    if (message.selector !== undefined) {
      Selector.encode(message.selector, writer.uint32(34).fork()).ldelim();
    }
    if (message.snapshotId !== "") {
      writer.uint32(42).string(message.snapshotId);
    }
    if (message.text !== "") {
      writer.uint32(50).string(message.text);
    }
    if (message.clearBeforeType !== false) {
      writer.uint32(56).bool(message.clearBeforeType);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TypeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.coordinates = Coordinates.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.selector = Selector.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.text = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.clearBeforeType = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeRequest {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      refId: isSet(object.refId) ? globalThis.String(object.refId) : undefined,
      coordinates: isSet(object.coordinates) ? Coordinates.fromJSON(object.coordinates) : undefined,
      selector: isSet(object.selector) ? Selector.fromJSON(object.selector) : undefined,
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      clearBeforeType: isSet(object.clearBeforeType) ? globalThis.Boolean(object.clearBeforeType) : false,
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: TypeRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.refId !== undefined) {
      obj.refId = message.refId;
    }
    if (message.coordinates !== undefined) {
      obj.coordinates = Coordinates.toJSON(message.coordinates);
    }
    if (message.selector !== undefined) {
      obj.selector = Selector.toJSON(message.selector);
    }
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.clearBeforeType !== false) {
      obj.clearBeforeType = message.clearBeforeType;
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypeRequest>, I>>(base?: I): TypeRequest {
    return TypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypeRequest>, I>>(object: I): TypeRequest {
    const message = createBaseTypeRequest();
    message.deviceId = object.deviceId ?? "";
    message.refId = object.refId ?? undefined;
    message.coordinates = (object.coordinates !== undefined && object.coordinates !== null)
      ? Coordinates.fromPartial(object.coordinates)
      : undefined;
    message.selector = (object.selector !== undefined && object.selector !== null)
      ? Selector.fromPartial(object.selector)
      : undefined;
    message.snapshotId = object.snapshotId ?? "";
    message.text = object.text ?? "";
    message.clearBeforeType = object.clearBeforeType ?? false;
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseSwipeRequest(): SwipeRequest {
  return {
    deviceId: "",
    start: undefined,
    end: undefined,
    direction: 0,
    distancePx: 0,
    durationMs: 0,
    options: undefined,
  };
}

export const SwipeRequest = {
  encode(message: SwipeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.start !== undefined) {
      Coordinates.encode(message.start, writer.uint32(18).fork()).ldelim();
    }
    if (message.end !== undefined) {
      Coordinates.encode(message.end, writer.uint32(26).fork()).ldelim();
    }
    if (message.direction !== 0) {
      writer.uint32(32).int32(message.direction);
    }
    if (message.distancePx !== 0) {
      writer.uint32(40).int32(message.distancePx);
    }
    if (message.durationMs !== 0) {
      writer.uint32(48).int32(message.durationMs);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwipeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwipeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.start = Coordinates.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.end = Coordinates.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.distancePx = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.durationMs = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwipeRequest {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      start: isSet(object.start) ? Coordinates.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? Coordinates.fromJSON(object.end) : undefined,
      direction: isSet(object.direction) ? directionFromJSON(object.direction) : 0,
      distancePx: isSet(object.distancePx) ? globalThis.Number(object.distancePx) : 0,
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: SwipeRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.start !== undefined) {
      obj.start = Coordinates.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = Coordinates.toJSON(message.end);
    }
    if (message.direction !== 0) {
      obj.direction = directionToJSON(message.direction);
    }
    if (message.distancePx !== 0) {
      obj.distancePx = Math.round(message.distancePx);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwipeRequest>, I>>(base?: I): SwipeRequest {
    return SwipeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwipeRequest>, I>>(object: I): SwipeRequest {
    const message = createBaseSwipeRequest();
    message.deviceId = object.deviceId ?? "";
    message.start = (object.start !== undefined && object.start !== null)
      ? Coordinates.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Coordinates.fromPartial(object.end) : undefined;
    message.direction = object.direction ?? 0;
    message.distancePx = object.distancePx ?? 0;
    message.durationMs = object.durationMs ?? 0;
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseActionResponse(): ActionResponse {
  return {
    deviceId: "",
    actionId: "",
    status: 0,
    startedAtUnixMs: "0",
    completedAtUnixMs: "0",
    errorCode: "",
    errorMessage: "",
    metadata: {},
  };
}

export const ActionResponse = {
  encode(message: ActionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.actionId !== "") {
      writer.uint32(18).string(message.actionId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.startedAtUnixMs !== "0") {
      writer.uint32(32).int64(message.startedAtUnixMs);
    }
    if (message.completedAtUnixMs !== "0") {
      writer.uint32(40).int64(message.completedAtUnixMs);
    }
    if (message.errorCode !== "") {
      writer.uint32(50).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(58).string(message.errorMessage);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ActionResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actionId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.startedAtUnixMs = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.completedAtUnixMs = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = ActionResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : "",
      status: isSet(object.status) ? actionStatusFromJSON(object.status) : 0,
      startedAtUnixMs: isSet(object.startedAtUnixMs) ? globalThis.String(object.startedAtUnixMs) : "0",
      completedAtUnixMs: isSet(object.completedAtUnixMs) ? globalThis.String(object.completedAtUnixMs) : "0",
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ActionResponse): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.status !== 0) {
      obj.status = actionStatusToJSON(message.status);
    }
    if (message.startedAtUnixMs !== "0") {
      obj.startedAtUnixMs = message.startedAtUnixMs;
    }
    if (message.completedAtUnixMs !== "0") {
      obj.completedAtUnixMs = message.completedAtUnixMs;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionResponse>, I>>(base?: I): ActionResponse {
    return ActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionResponse>, I>>(object: I): ActionResponse {
    const message = createBaseActionResponse();
    message.deviceId = object.deviceId ?? "";
    message.actionId = object.actionId ?? "";
    message.status = object.status ?? 0;
    message.startedAtUnixMs = object.startedAtUnixMs ?? "0";
    message.completedAtUnixMs = object.completedAtUnixMs ?? "0";
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseActionResponse_MetadataEntry(): ActionResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const ActionResponse_MetadataEntry = {
  encode(message: ActionResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActionResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ActionResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionResponse_MetadataEntry>, I>>(base?: I): ActionResponse_MetadataEntry {
    return ActionResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionResponse_MetadataEntry>, I>>(object: I): ActionResponse_MetadataEntry {
    const message = createBaseActionResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseScreenshotStreamRequest(): ScreenshotStreamRequest {
  return { deviceId: "", maxFps: 0, jpegQuality: 0, maxWidth: 0, maxHeight: 0, maxFrames: 0, options: undefined };
}

export const ScreenshotStreamRequest = {
  encode(message: ScreenshotStreamRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.maxFps !== 0) {
      writer.uint32(16).uint32(message.maxFps);
    }
    if (message.jpegQuality !== 0) {
      writer.uint32(24).uint32(message.jpegQuality);
    }
    if (message.maxWidth !== 0) {
      writer.uint32(32).uint32(message.maxWidth);
    }
    if (message.maxHeight !== 0) {
      writer.uint32(40).uint32(message.maxHeight);
    }
    if (message.maxFrames !== 0) {
      writer.uint32(48).uint32(message.maxFrames);
    }
    if (message.options !== undefined) {
      RequestOptions.encode(message.options, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScreenshotStreamRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxFps = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.jpegQuality = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxWidth = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxHeight = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.maxFrames = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.options = RequestOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotStreamRequest {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      maxFps: isSet(object.maxFps) ? globalThis.Number(object.maxFps) : 0,
      jpegQuality: isSet(object.jpegQuality) ? globalThis.Number(object.jpegQuality) : 0,
      maxWidth: isSet(object.maxWidth) ? globalThis.Number(object.maxWidth) : 0,
      maxHeight: isSet(object.maxHeight) ? globalThis.Number(object.maxHeight) : 0,
      maxFrames: isSet(object.maxFrames) ? globalThis.Number(object.maxFrames) : 0,
      options: isSet(object.options) ? RequestOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ScreenshotStreamRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.maxFps !== 0) {
      obj.maxFps = Math.round(message.maxFps);
    }
    if (message.jpegQuality !== 0) {
      obj.jpegQuality = Math.round(message.jpegQuality);
    }
    if (message.maxWidth !== 0) {
      obj.maxWidth = Math.round(message.maxWidth);
    }
    if (message.maxHeight !== 0) {
      obj.maxHeight = Math.round(message.maxHeight);
    }
    if (message.maxFrames !== 0) {
      obj.maxFrames = Math.round(message.maxFrames);
    }
    if (message.options !== undefined) {
      obj.options = RequestOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotStreamRequest>, I>>(base?: I): ScreenshotStreamRequest {
    return ScreenshotStreamRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotStreamRequest>, I>>(object: I): ScreenshotStreamRequest {
    const message = createBaseScreenshotStreamRequest();
    message.deviceId = object.deviceId ?? "";
    message.maxFps = object.maxFps ?? 0;
    message.jpegQuality = object.jpegQuality ?? 0;
    message.maxWidth = object.maxWidth ?? 0;
    message.maxHeight = object.maxHeight ?? 0;
    message.maxFrames = object.maxFrames ?? 0;
    message.options = (object.options !== undefined && object.options !== null)
      ? RequestOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseScreenshotFrameMeta(): ScreenshotFrameMeta {
  return {
    frameId: "",
    deviceId: "",
    width: 0,
    height: 0,
    mimeType: "",
    totalBytes: "0",
    chunkCount: 0,
    capturedAtUnixMs: "0",
  };
}

export const ScreenshotFrameMeta = {
  encode(message: ScreenshotFrameMeta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frameId !== "") {
      writer.uint32(10).string(message.frameId);
    }
    if (message.deviceId !== "") {
      writer.uint32(18).string(message.deviceId);
    }
    if (message.width !== 0) {
      writer.uint32(24).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).uint32(message.height);
    }
    if (message.mimeType !== "") {
      writer.uint32(42).string(message.mimeType);
    }
    if (message.totalBytes !== "0") {
      writer.uint32(48).uint64(message.totalBytes);
    }
    if (message.chunkCount !== 0) {
      writer.uint32(56).uint32(message.chunkCount);
    }
    if (message.capturedAtUnixMs !== "0") {
      writer.uint32(64).int64(message.capturedAtUnixMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScreenshotFrameMeta {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotFrameMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.frameId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.height = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalBytes = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.chunkCount = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.capturedAtUnixMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotFrameMeta {
    return {
      frameId: isSet(object.frameId) ? globalThis.String(object.frameId) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      totalBytes: isSet(object.totalBytes) ? globalThis.String(object.totalBytes) : "0",
      chunkCount: isSet(object.chunkCount) ? globalThis.Number(object.chunkCount) : 0,
      capturedAtUnixMs: isSet(object.capturedAtUnixMs) ? globalThis.String(object.capturedAtUnixMs) : "0",
    };
  },

  toJSON(message: ScreenshotFrameMeta): unknown {
    const obj: any = {};
    if (message.frameId !== "") {
      obj.frameId = message.frameId;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.totalBytes !== "0") {
      obj.totalBytes = message.totalBytes;
    }
    if (message.chunkCount !== 0) {
      obj.chunkCount = Math.round(message.chunkCount);
    }
    if (message.capturedAtUnixMs !== "0") {
      obj.capturedAtUnixMs = message.capturedAtUnixMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotFrameMeta>, I>>(base?: I): ScreenshotFrameMeta {
    return ScreenshotFrameMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotFrameMeta>, I>>(object: I): ScreenshotFrameMeta {
    const message = createBaseScreenshotFrameMeta();
    message.frameId = object.frameId ?? "";
    message.deviceId = object.deviceId ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.mimeType = object.mimeType ?? "";
    message.totalBytes = object.totalBytes ?? "0";
    message.chunkCount = object.chunkCount ?? 0;
    message.capturedAtUnixMs = object.capturedAtUnixMs ?? "0";
    return message;
  },
};

function createBaseScreenshotChunk(): ScreenshotChunk {
  return { frameId: "", chunkIndex: 0, data: new Uint8Array(0) };
}

export const ScreenshotChunk = {
  encode(message: ScreenshotChunk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frameId !== "") {
      writer.uint32(10).string(message.frameId);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(16).uint32(message.chunkIndex);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScreenshotChunk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.frameId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chunkIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotChunk {
    return {
      frameId: isSet(object.frameId) ? globalThis.String(object.frameId) : "",
      chunkIndex: isSet(object.chunkIndex) ? globalThis.Number(object.chunkIndex) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ScreenshotChunk): unknown {
    const obj: any = {};
    if (message.frameId !== "") {
      obj.frameId = message.frameId;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotChunk>, I>>(base?: I): ScreenshotChunk {
    return ScreenshotChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotChunk>, I>>(object: I): ScreenshotChunk {
    const message = createBaseScreenshotChunk();
    message.frameId = object.frameId ?? "";
    message.chunkIndex = object.chunkIndex ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStreamHeartbeat(): StreamHeartbeat {
  return { unixMs: "0" };
}

export const StreamHeartbeat = {
  encode(message: StreamHeartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unixMs !== "0") {
      writer.uint32(8).int64(message.unixMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamHeartbeat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unixMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamHeartbeat {
    return { unixMs: isSet(object.unixMs) ? globalThis.String(object.unixMs) : "0" };
  },

  toJSON(message: StreamHeartbeat): unknown {
    const obj: any = {};
    if (message.unixMs !== "0") {
      obj.unixMs = message.unixMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamHeartbeat>, I>>(base?: I): StreamHeartbeat {
    return StreamHeartbeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamHeartbeat>, I>>(object: I): StreamHeartbeat {
    const message = createBaseStreamHeartbeat();
    message.unixMs = object.unixMs ?? "0";
    return message;
  },
};

function createBaseStreamEnd(): StreamEnd {
  return { reason: "" };
}

export const StreamEnd = {
  encode(message: StreamEnd, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamEnd {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamEnd {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: StreamEnd): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamEnd>, I>>(base?: I): StreamEnd {
    return StreamEnd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamEnd>, I>>(object: I): StreamEnd {
    const message = createBaseStreamEnd();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseScreenshotStreamEvent(): ScreenshotStreamEvent {
  return { frameMeta: undefined, chunk: undefined, heartbeat: undefined, end: undefined };
}

export const ScreenshotStreamEvent = {
  encode(message: ScreenshotStreamEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frameMeta !== undefined) {
      ScreenshotFrameMeta.encode(message.frameMeta, writer.uint32(10).fork()).ldelim();
    }
    if (message.chunk !== undefined) {
      ScreenshotChunk.encode(message.chunk, writer.uint32(18).fork()).ldelim();
    }
    if (message.heartbeat !== undefined) {
      StreamHeartbeat.encode(message.heartbeat, writer.uint32(26).fork()).ldelim();
    }
    if (message.end !== undefined) {
      StreamEnd.encode(message.end, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScreenshotStreamEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotStreamEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.frameMeta = ScreenshotFrameMeta.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chunk = ScreenshotChunk.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.heartbeat = StreamHeartbeat.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.end = StreamEnd.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotStreamEvent {
    return {
      frameMeta: isSet(object.frameMeta) ? ScreenshotFrameMeta.fromJSON(object.frameMeta) : undefined,
      chunk: isSet(object.chunk) ? ScreenshotChunk.fromJSON(object.chunk) : undefined,
      heartbeat: isSet(object.heartbeat) ? StreamHeartbeat.fromJSON(object.heartbeat) : undefined,
      end: isSet(object.end) ? StreamEnd.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: ScreenshotStreamEvent): unknown {
    const obj: any = {};
    if (message.frameMeta !== undefined) {
      obj.frameMeta = ScreenshotFrameMeta.toJSON(message.frameMeta);
    }
    if (message.chunk !== undefined) {
      obj.chunk = ScreenshotChunk.toJSON(message.chunk);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = StreamHeartbeat.toJSON(message.heartbeat);
    }
    if (message.end !== undefined) {
      obj.end = StreamEnd.toJSON(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotStreamEvent>, I>>(base?: I): ScreenshotStreamEvent {
    return ScreenshotStreamEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotStreamEvent>, I>>(object: I): ScreenshotStreamEvent {
    const message = createBaseScreenshotStreamEvent();
    message.frameMeta = (object.frameMeta !== undefined && object.frameMeta !== null)
      ? ScreenshotFrameMeta.fromPartial(object.frameMeta)
      : undefined;
    message.chunk = (object.chunk !== undefined && object.chunk !== null)
      ? ScreenshotChunk.fromPartial(object.chunk)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? StreamHeartbeat.fromPartial(object.heartbeat)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? StreamEnd.fromPartial(object.end) : undefined;
    return message;
  },
};

export type MobileAutomationServiceService = typeof MobileAutomationServiceService;
export const MobileAutomationServiceService = {
  listDevices: {
    path: "/mobile.v1.MobileAutomationService/ListDevices",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDevicesRequest) => Buffer.from(ListDevicesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListDevicesRequest.decode(value),
    responseSerialize: (value: ListDevicesResponse) => Buffer.from(ListDevicesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListDevicesResponse.decode(value),
  },
  getActiveApp: {
    path: "/mobile.v1.MobileAutomationService/GetActiveApp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetActiveAppRequest) => Buffer.from(GetActiveAppRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetActiveAppRequest.decode(value),
    responseSerialize: (value: GetActiveAppResponse) => Buffer.from(GetActiveAppResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetActiveAppResponse.decode(value),
  },
  getUiTree: {
    path: "/mobile.v1.MobileAutomationService/GetUITree",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUITreeRequest) => Buffer.from(GetUITreeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUITreeRequest.decode(value),
    responseSerialize: (value: GetUITreeResponse) => Buffer.from(GetUITreeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUITreeResponse.decode(value),
  },
  findElements: {
    path: "/mobile.v1.MobileAutomationService/FindElements",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FindElementsRequest) => Buffer.from(FindElementsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FindElementsRequest.decode(value),
    responseSerialize: (value: FindElementsResponse) => Buffer.from(FindElementsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FindElementsResponse.decode(value),
  },
  tap: {
    path: "/mobile.v1.MobileAutomationService/Tap",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TapRequest) => Buffer.from(TapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TapRequest.decode(value),
    responseSerialize: (value: ActionResponse) => Buffer.from(ActionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ActionResponse.decode(value),
  },
  type: {
    path: "/mobile.v1.MobileAutomationService/Type",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TypeRequest) => Buffer.from(TypeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TypeRequest.decode(value),
    responseSerialize: (value: ActionResponse) => Buffer.from(ActionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ActionResponse.decode(value),
  },
  swipe: {
    path: "/mobile.v1.MobileAutomationService/Swipe",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SwipeRequest) => Buffer.from(SwipeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SwipeRequest.decode(value),
    responseSerialize: (value: ActionResponse) => Buffer.from(ActionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ActionResponse.decode(value),
  },
  screenshotStream: {
    path: "/mobile.v1.MobileAutomationService/ScreenshotStream",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ScreenshotStreamRequest) => Buffer.from(ScreenshotStreamRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ScreenshotStreamRequest.decode(value),
    responseSerialize: (value: ScreenshotStreamEvent) => Buffer.from(ScreenshotStreamEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScreenshotStreamEvent.decode(value),
  },
} as const;

export interface MobileAutomationServiceServer extends UntypedServiceImplementation {
  listDevices: handleUnaryCall<ListDevicesRequest, ListDevicesResponse>;
  getActiveApp: handleUnaryCall<GetActiveAppRequest, GetActiveAppResponse>;
  getUiTree: handleUnaryCall<GetUITreeRequest, GetUITreeResponse>;
  findElements: handleUnaryCall<FindElementsRequest, FindElementsResponse>;
  tap: handleUnaryCall<TapRequest, ActionResponse>;
  type: handleUnaryCall<TypeRequest, ActionResponse>;
  swipe: handleUnaryCall<SwipeRequest, ActionResponse>;
  screenshotStream: handleServerStreamingCall<ScreenshotStreamRequest, ScreenshotStreamEvent>;
}

export interface MobileAutomationServiceClient extends Client {
  listDevices(
    request: ListDevicesRequest,
    callback: (error: ServiceError | null, response: ListDevicesResponse) => void,
  ): ClientUnaryCall;
  listDevices(
    request: ListDevicesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListDevicesResponse) => void,
  ): ClientUnaryCall;
  listDevices(
    request: ListDevicesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListDevicesResponse) => void,
  ): ClientUnaryCall;
  getActiveApp(
    request: GetActiveAppRequest,
    callback: (error: ServiceError | null, response: GetActiveAppResponse) => void,
  ): ClientUnaryCall;
  getActiveApp(
    request: GetActiveAppRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetActiveAppResponse) => void,
  ): ClientUnaryCall;
  getActiveApp(
    request: GetActiveAppRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetActiveAppResponse) => void,
  ): ClientUnaryCall;
  getUiTree(
    request: GetUITreeRequest,
    callback: (error: ServiceError | null, response: GetUITreeResponse) => void,
  ): ClientUnaryCall;
  getUiTree(
    request: GetUITreeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUITreeResponse) => void,
  ): ClientUnaryCall;
  getUiTree(
    request: GetUITreeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUITreeResponse) => void,
  ): ClientUnaryCall;
  findElements(
    request: FindElementsRequest,
    callback: (error: ServiceError | null, response: FindElementsResponse) => void,
  ): ClientUnaryCall;
  findElements(
    request: FindElementsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FindElementsResponse) => void,
  ): ClientUnaryCall;
  findElements(
    request: FindElementsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FindElementsResponse) => void,
  ): ClientUnaryCall;
  tap(request: TapRequest, callback: (error: ServiceError | null, response: ActionResponse) => void): ClientUnaryCall;
  tap(
    request: TapRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ActionResponse) => void,
  ): ClientUnaryCall;
  tap(
    request: TapRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ActionResponse) => void,
  ): ClientUnaryCall;
  type(request: TypeRequest, callback: (error: ServiceError | null, response: ActionResponse) => void): ClientUnaryCall;
  type(
    request: TypeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ActionResponse) => void,
  ): ClientUnaryCall;
  type(
    request: TypeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ActionResponse) => void,
  ): ClientUnaryCall;
  swipe(
    request: SwipeRequest,
    callback: (error: ServiceError | null, response: ActionResponse) => void,
  ): ClientUnaryCall;
  swipe(
    request: SwipeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ActionResponse) => void,
  ): ClientUnaryCall;
  swipe(
    request: SwipeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ActionResponse) => void,
  ): ClientUnaryCall;
  screenshotStream(
    request: ScreenshotStreamRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ScreenshotStreamEvent>;
  screenshotStream(
    request: ScreenshotStreamRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ScreenshotStreamEvent>;
}

export const MobileAutomationServiceClient = makeGenericClientConstructor(
  MobileAutomationServiceService,
  "mobile.v1.MobileAutomationService",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): MobileAutomationServiceClient;
  service: typeof MobileAutomationServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
